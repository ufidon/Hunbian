#include <iostream>
#include <string>
#include <sstream>
#include <vector>
#include <map>
#include <algorithm>
#include <iterator>
#include <functional>
#include <random>
#include <numeric>
#include <utility>
#include <cmath>

using namespace std;

typedef int 号型;
typedef int 键型;
typedef vector<键型> 列型;

class 寻
{
public:
    列型 数;
    键型 标;
    static int 比次; // 比标总次数
    static int 赋次; //

public:
    寻() {}
    寻(const 列型 &数, const 键型 &标) : 数(数), 标(标)
    {
    }

    // 课本10页算法1.5: 折半寻标
    static bool 折半寻(const 列型 &数, const 键型 &标, 号型 &位)
    {
        号型 左, 中, 右;
        bool 寻着 = false;
        比次 = 0;
        左 = 0;
        右 = 数.size() - 1;
        位 = -1;

        while (左 <= 右 && 位 == -1)
        {
            中 = (左 + 右) / 2;

            cout << "(左,中,右:" << 左 << "," << 中 << "," << 右 << ")" << endl;

            if (标 == 数[中])
                位 = 中, 比次++, 寻着 = true;
            else if (标 < 数[中])
                右 = 中 - 1, 比次++;
            else
                左 = 中 + 1, 比次++;
        }

        return 寻着;
    }

    // 课本349页算法8.1: 插值寻标
    static bool 插寻(const 列型 &数, const 键型 &标, 号型 &位)
    {
        号型 左, 中, 右;
        bool 寻着 = false;
        double 寻域;
        比次 = 0;
        左 = 0;
        右 = 数.size() - 1;
        位 = -1;

        if (数[左] <= 标 && 标 <= 数[右])
        {
            while (左 <= 右 && 位 == -1)
            {
                寻域 = 数[右] - 数[左];
                if (寻域 == 0)
                    中 = 左;
                else
                    中 = 左 + floor((标 - 数[左]) * (右 - 左) / 寻域);

                cout << "(左,中,右:" << 左 << "," << 中 << "," << 右 << ")" << endl;

                if (标 == 数[中])
                    位 = 中, 比次++, 寻着 = true;
                else if (标 < 数[中])
                    右 = 中 - 1, 比次++;
                else
                    左 = 中 + 1, 比次++;
            }
        }
        return 寻着;
    }

    // 课本350页算法8.2: 壮插值寻标
    static bool 壮插寻(const 列型 &数, const 键型 &标, 号型 &位)
    {
        号型 左, 中, 右;
        bool 寻着 = false;
        double 寻域, 隙;

        比次 = 0;
        左 = 0;
        右 = 数.size() - 1;
        位 = -1;

        if (数[左] <= 标 && 标 <= 数[右])
        {
            while (左 <= 右 && 位 == -1)
            {
                寻域 = 数[右] - 数[左];
                隙 = floor(sqrt(右 - 左 + 1));

                if (寻域 == 0)
                    中 = 左;
                else
                {
                    中 = 左 + floor((标 - 数[左]) * (右 - 左) / 寻域);
                    中 = min<号型>(右 - 隙, max<号型>(中, 左 + 隙));
                }

                cout << "(左,中,右:" << 左 << "," << 中 << "," << 右 << ")" << endl;

                if (标 == 数[中])
                {
                    比次++;
                    位 = 中;
                    寻着 = true;
                }
                else if (标 < 数[中])
                {
                    比次++;
                    右 = 中 - 1;
                }
                else
                    左 = 中 + 1, 比次++;
            }
        }
        return 寻着;
    }

    // 课本363页算法8.2: 寻最大值
    static 号型 寻丄(const 列型 &数, 键型 &丄)
    {
        号型 号 = 0, 位 = 0;
        丄 = 数[0];
        比次 = 0;

        for (号 = 1; 号 < 数.size(); 号++)
        {
            比次++;
            if (丄 < 数[号])
                丄 = 数[号], 位 = 号;
        }
        return 位;
    }

    // 课本372页算法: 淘汰赛法, 寻老二,返寻着否
    static bool 寻老二(const 列型 &数, 键型 &老二, 号型 &老二号)
    {
        bool 寻着 = true;
        int 对数 = 数.size() / 2;

        比次 = 0;
        if (数.size() == 1)
            寻着 = false;

        if (数.size() == 2)
        {
            比次++;
            if (数[0] < 数[1])
            {
                老二 = 数[0];
                老二号 = 0;
            }
            else
            {
                老二 = 数[1];
                老二号 = 1;
            }
        }

        vector<号型> 号(数.size());
        iota(号.begin(), 号.end(), 0);

        老二号 = 寻老贰(数, 号, 老二);

        return 寻着;
    }

    static 号型 寻老贰(const 列型 &数,         // 初始数列
                       const vector<号型> &号, // 每轮淘汰赛结果在初始数列中的号
                       键型 &老二)
    {
        static vector<vector<号型>> 败将(数.size()); // 败将[赢者][败者] 赢者之败将在初始数列中的号
        vector<号型> 胜者;

        if (号.size() == 1) // 只剩老大之号=号[0]
        {
            号型 老大号 = 号[0];
            老二 = 数[败将[老大号][0]];
            int 老二位号 = 0;
            cout << "老大败将:[" << 老二 << ",";
            for (int i = 1; i < 败将[老大号].size(); i++)
            {
                比次++;
                cout << 数[败将[老大号][i]] << (i == 败将[老大号].size() - 1 ? "]" : ",");
                if (老二 < 数[败将[老大号][i]])
                {
                    老二 = 数[败将[老大号][i]];
                    老二位号 = 败将[老大号][i];
                }
            }
            cout << "\n老大败将号:" << 印列(败将[老大号]) << endl;
            return 老二位号;
        }

        // 淘汰赛, 数列长最短为2
        int 对数 = 号.size() / 2;
        for (int 对 = 0; 对 < 对数; 对++)
        {
            比次++;
            if (数[号[2 * 对]] < 数[号[2 * 对 + 1]])
            {
                胜者.push_back(号[2 * 对 + 1]);
                败将[号[2 * 对 + 1]].push_back(号[2 * 对]);
                cout << "(" << 数[号[2 * 对]] << ":" << 数[号[2 * 对 + 1]] << ")->" << 数[号[2 * 对 + 1]] << endl;
            }
            else
            {
                胜者.push_back(号[2 * 对]);
                败将[号[2 * 对]].push_back(号[2 * 对 + 1]);
                cout << "(" << 数[号[2 * 对]] << ":" << 数[号[2 * 对 + 1]] << ")->" << 数[号[2 * 对]] << endl;
            }
        }
        // 奇数个参赛者
        if (号.size() % 2)
            胜者.push_back(号[号.size() - 1]);

        return 寻老贰(数, 胜者, 老二);
    }

    static bool 寻老2(const 列型 &数, 键型 &老二, 号型 &老二号)
    {
        bool 寻着 = true;
        int 对数 = 数.size() / 2;

        比次 = 0;
        if (数.size() == 1)
            寻着 = false;

        if (数.size() == 2)
        {
            比次++;
            if (数[0] < 数[1])
            {
                老二 = 数[0];
                老二号 = 0;
            }
            else
            {
                老二 = 数[1];
                老二号 = 1;
            }
        }

        vector<号型> 号(数.size());
        iota(号.begin(), 号.end(), 0);
        static vector<vector<号型>> 败将(数.size()); // 败将[赢者][败者] 赢者之败将在初始数列中的号
        vector<号型> 胜者;

        while (号.size() > 1)
        {
            // 淘汰赛, 数列长最短为2
            对数 = 号.size() / 2;
            for (int 对 = 0; 对 < 对数; 对++)
            {
                比次++;
                if (数[号[2 * 对]] < 数[号[2 * 对 + 1]])
                {
                    胜者.push_back(号[2 * 对 + 1]);
                    败将[号[2 * 对 + 1]].push_back(号[2 * 对]);
                    cout << "(" << 数[号[2 * 对]] << ":" << 数[号[2 * 对 + 1]] << ")->" << 数[号[2 * 对 + 1]] << endl;
                }
                else
                {
                    胜者.push_back(号[2 * 对]);
                    败将[号[2 * 对]].push_back(号[2 * 对 + 1]);
                    cout << "(" << 数[号[2 * 对]] << ":" << 数[号[2 * 对 + 1]] << ")->" << 数[号[2 * 对]] << endl;
                }
            }
            // 奇数个参赛者
            if (号.size() % 2)
                胜者.push_back(号[号.size() - 1]);

            号 = 胜者;
            胜者.clear();
        }

        // 必须成立, 无需判之
        if (号.size() == 1) // 只剩老大之号=号[0]
        {
            号型 老大号 = 号[0];
            老二 = 数[败将[老大号][0]];
            cout << "老大败将:[" << 老二 << ",";
            for (int i = 1; i < 败将[老大号].size(); i++)
            {
                比次++;
                cout << 数[败将[老大号][i]] << (i == 败将[老大号].size() - 1 ? "]" : ",");
                if (老二 < 数[败将[老大号][i]])
                {
                    老二 = 数[败将[老大号][i]];
                    老二号 = 败将[老大号][i];
                }
            }
            cout << "\n老大败将号:" << 印列(败将[老大号]) << endl;
        }

        return 寻着;
    }

    // 课本364页算法8.3: 寻最大值及最小值
    static void 寻丄丅(const 列型 &数, 键型 &丄, 键型 &丅, 号型 &丄位, 号型 &丅位)
    {
        号型 号 = 0;
        丄位 = 丅位 = 0;
        丄 = 丅 = 数[0];
        比次 = 0;

        for (号 = 1; 号 < 数.size(); 号++)
        {
            比次++;
            if (丄 < 数[号])
                丄 = 数[号], 丄位 = 号;
            if (丅 > 数[号])
                丅 = 数[号], 丅位 = 号;
        }
    }

    // 课本365页算法8.4: 寻最大值及最小值
    static void 双寻(const 列型 &数, 键型 &丄, 键型 &丅, 号型 &丄位, 号型 &丅位)
    {
        号型 号 = 0;
        比次 = 0;
        int 对数 = 数.size() / 2;

        if (数.size() == 1)
        { // 不用比
            丄 = 数[0], 丄位 = 0, 丅 = 数[0], 丅位 = 0;
            return;
        }

        if (对数 >= 1)
        {
            比次++;
            if (数[0] < 数[1])
                丄 = 数[1], 丄位 = 1, 丅 = 数[0], 丅位 = 0;
            else
                丄 = 数[0], 丄位 = 0, 丅 = 数[1], 丅位 = 1;
        }

        for (号型 对 = 1; 对 < 对数; 对++)
        {
            比次 += 3;
            if (数[2 * 对] < 数[2 * 对 + 1])
            {
                if (丄 < 数[2 * 对 + 1])
                    丄 = 数[2 * 对 + 1], 丄位 = 2 * 对 + 1;
                if (丅 > 数[2 * 对])
                    丅 = 数[2 * 对], 丅位 = 2 * 对;
            }
            else
            {
                if (丄 < 数[2 * 对])
                    丄 = 数[2 * 对], 丄位 = 2 * 对;
                if (丅 > 数[2 * 对 + 1])
                    丅 = 数[2 * 对 + 1], 丅位 = 2 * 对 + 1;
            }
        }

        // 若还剩一个, 列长为奇数
        if (对数 >= 1 && 数.size() - 2 * 对数 == 1)
        {
            号 = 数.size() - 1;
            比次 += 2;
            if (丄 < 数[号])
                丄 = 数[号], 丄位 = 号;
            if (丅 > 数[号])
                丅 = 数[号], 丅位 = 号;
        }
    }

    // 课本377页算法8.5: 寻老几, 几号最小值
    // 左值为桩: 数随机分布时性能为线性, 递增分布时为平方
    static 键型 寻老几(列型 &数, 号型 左, 号型 右, 号型 几)
    {
        号型 桩号;
        if (左 == 右)
            return 数[左];
        else
        {
            划(数, 左, 右, 桩号);
            if (几 == 桩号)
                return 数[桩号];
            else
            {
                if (几 < 桩号)
                    return 寻老几(数, 左, 桩号 - 1, 几);
                else
                    return 寻老几(数, 桩号 + 1, 右, 几);
            }
        }
    }
    static void 划(列型 &数, 号型 左, 号型 右, 号型 &桩号)
    {
        号型 步, 桩步;
        键型 桩;

        桩 = 数[左]; // 左值为桩
        桩步 = 左;
        for (步 = 左 + 1; 步 <= 右; 步++)
        {
            比次++; // 桩与列元之比
            if (数[步] < 桩)
            {
                桩步++;
                swap(数[步], 数[桩步]);
            }
        }
        桩号 = 桩步;
        swap(数[左], 数[桩号]);
    }

    // 课本381页算法8.6中值法: 寻老几, 几号最小值
    // 估计之中值为桩: 保证线性性能, 但其线性系数大, 源于估值
    static 键型 寻老几2(列型 &数, 号型 左, 号型 右, 号型 几)
    {
        号型 桩号;
        if (左 == 右)
            return 数[左];
        else
        {
            划2(数, 左, 右, 桩号);
            if (几 == 桩号)
                return 数[桩号];
            else
            {
                if (几 < 桩号)
                    return 寻老几2(数, 左, 桩号 - 1, 几);
                else
                    return 寻老几2(数, 桩号 + 1, 右, 几);
            }
        }
    }

    static void 划2(列型 &数, 号型 左, 号型 右, 号型 &桩号)
    {
#define 段长 5
        int 列长 = 右 - 左 + 1;
        int 段数 = ceil((double)列长 / 段长);

        号型 步, 桩步, 桩标, 段首, 段尾;
        键型 桩;
        vector<键型> 段中值(段数);

        for (int 段 = 0; 段 < 段数; 段++)
        {
            段首 = 左 + 段 * 段长;
            段尾 = min<号型>(左 + (段 + 1) * 段长 - 1, 左 + 列长 - 1);
            列型 此段(数.begin() + 段首, 数.begin() + 段尾 + 1);
            段中值[段] = 一至五中(此段);
        }

        // 估之中值为桩
        桩 = 寻老几2(段中值, 0, 段中值.size() - 1, 段数 / 2);

        桩步 = 左;
        for (步 = 左; 步 <= 右; 步++)
        {
            比次++; // 桩与列元之比
            if (数[步] == 桩)
            {
                swap(数[步], 数[桩步]);
                桩标 = 桩步;
                桩步++;
            }
            else
            {
                if (数[步] < 桩)
                {
                    swap(数[步], 数[桩步]);
                    桩步++;
                }
            }
        }
        桩号 = 桩步 - 1;
        swap(数[桩标], 数[桩号]);
    }

    static 键型 一至五中(列型 &数)
    {
        if (数.size() == 1 || 数.size() == 2)
            return 数[0];
        if (数.size() == 3)
        {
            if (数[0] > 数[1])
                swap(数[0], 数[1]);
            if (数[1] < 数[2])
                return 数[1];
            else
                return max(数[0], 数[2]);
        }
        if (数.size() == 4)
        {
            if (数[0] > 数[1])
                swap(数[0], 数[1]);
            if (数[2] > 数[3])
                swap(数[2], 数[3]);
            if (数[1] < 数[3])
                return 数[1];
            else
                return 数[3];
        }
        // 数.size() == 5
        return 五中(数);
    }

    static 键型 五中(列型 &数)
    {
        if (数[0] > 数[1])
            swap(数[0], 数[1]);
        if (数[3] > 数[4])
            swap(数[4], 数[5]);
        if (数[0] > 数[3])
            swap(数[0], 数[3]);

        if (数[2] > 数[1])
        {
            if (数[1] < 数[3])
                return min(数[2], 数[3]);
            else
                return min(数[1], 数[4]);
        }
        else
        {
            if (数[2] > 数[3])
                return min(数[2], 数[4]);
            else
                return min(数[1], 数[3]);
        }
    }

    // 课本387页算法8.7: 寻老几, 几号最小值
    // 随机取桩: 平均性能为线性, 无算法8.5之缺点. 但需数均匀分布
    static 键型 寻老几3(列型 &数, 号型 左, 号型 右, 号型 几)
    {
        号型 桩号;
        if (左 == 右)
            return 数[左];
        else
        {
            划3(数, 左, 右, 桩号);
            if (几 == 桩号)
                return 数[桩号];
            else
            {
                if (几 < 桩号)
                    return 寻老几3(数, 左, 桩号 - 1, 几);
                else
                    return 寻老几3(数, 桩号 + 1, 右, 几);
            }
        }
    }
    static void 划3(列型 &数, 号型 左, 号型 右, 号型 &桩号)
    {
        号型 步, 桩步, 随机桩号;
        键型 桩;

        static default_random_engine 随机源;
        uniform_int_distribution<号型> 均布(左, 右);
        随机桩号 = 均布(随机源);
        cout << "(左,随机桩号,右)=(" << 左 << "," << 随机桩号 << "," << 右 << ")" << endl;

        桩 = 数[随机桩号]; // 随机取桩

#ifdef 写法1        
        号型 桩标;
        桩步 = 左;
        for (步 = 左; 步 <= 右; 步++)
        {
            比次++; // 桩与列元之比
            if (数[步] == 桩)
            {
                swap(数[步], 数[桩步]);
                桩标 = 桩步;
                桩步++;
            }
            else if (数[步] < 桩)
            {
                swap(数[步], 数[桩步]);
                桩步++;
            }
        }
        桩号 = 桩步 - 1;
        swap(数[桩标], 数[桩号]);
#else
        swap(数[左], 数[随机桩号]);
        桩步 = 左;
        for (步 = 左 + 1; 步 <= 右; 步++)
        {
            比次++; // 桩与列元之比
            if (数[步] < 桩)
            {
                桩步++;
                swap(数[步], 数[桩步]);
            }
        }
        桩号 = 桩步;
        swap(数[左], 数[桩号]);        
#endif
    }
    // 印列

    static string 印列(int 列长, 键型 数[])
    {
        stringstream ss;
        ss << "[";
        for (号型 号 = 0; 号 <= 列长 - 1; 号++)
        {
            ss << 数[号] << (号 == 列长 - 1 ? "" : ",");
        }
        ss << "]";
        return ss.str();
    }

    static string 印列(const 列型 &数)
    {
        int 列长 = 数.size();
        stringstream ss;
        ss << "[";
        for (号型 号 = 0; 号 <= 列长 - 1; 号++)
        {
            ss << 数[号] << (号 == 列长 - 1 ? "" : ",");
        }
        ss << "]";
        return ss.str();
    }
    static string 印列(const 列型 &数, const 号型 起, const 号型 止)
    {
        stringstream ss;
        ss << "[";
        for (号型 号 = 起; 号 <= 止; 号++)
        {
            ss << 数[号] << (号 == 止 ? "" : ",");
        }
        ss << "]";
        return ss.str();
    }
};

int 寻::比次 = 0;
int 寻::赋次 = 0;

int main()
{

    列型 数 = {1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31};
    键型 标 = 19;
    列型 数2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 100};
    键型 标2 = 10;
    列型 数3 = {100, 29, 37, 49, 15, 66, 97, 18, 999, 100};
    列型 数4 = {12, 10, 5, 15, 18, 12, 4, 16};

    号型 位 = -1, 丄位 = -1, 丅位 = -1;
    键型 丄 = 0, 丅 = 0;

#if 0
    cout << "\n-------------折半寻---------------" << endl;
    寻 寻0(数, 标);
    cout << "在" << 寻0.印列(寻0.数) << "中寻" << 寻0.标 << endl;
    if (寻::折半寻(寻0.数, 寻0.标, 位))
    {
        cout << 寻0.标 << "位于数列中第" << 位 << "位" << endl;
    }
    else
        cout << 寻0.标 << "不在数列中" << endl;
    cout << "共比标" << 寻0.比次 << "次" << endl;

    寻 寻〇(数2, 标2);
    cout << "在" << 寻〇.印列(寻〇.数) << "中寻" << 寻〇.标 << endl;
    if (寻::折半寻(寻〇.数, 寻〇.标, 位))
    {
        cout << 寻〇.标 << "位于数列中第" << 位 << "位" << endl;
    }
    else
        cout << 寻〇.标 << "不在数列中" << endl;
    cout << "共比标" << 寻〇.比次 << "次" << endl;

    cout << "\n-------------插寻---------------" << endl;
    寻 寻1(数, 标);
    cout << "在" << 寻1.印列(寻1.数) << "中寻" << 寻1.标 << endl;
    if (寻::插寻(寻1.数, 寻1.标, 位))
    {
        cout << 寻1.标 << "位于数列中第" << 位 << "位" << endl;
    }
    else
        cout << 寻1.标 << "不在数列中" << endl;
    cout << "共比标" << 寻1.比次 << "次" << endl;

    寻 寻a(数2, 标2);
    cout << "在" << 寻a.印列(寻a.数) << "中寻" << 寻a.标 << endl;
    if (寻::插寻(寻a.数, 寻a.标, 位))
    {
        cout << 寻a.标 << "位于数列中第" << 位 << "位" << endl;
    }
    else
        cout << 寻a.标 << "不在数列中" << endl;
    cout << "共比标" << 寻a.比次 << "次" << endl;

    cout << "\n-------------强插寻---------------" << endl;
    寻 寻2(数, 标);
    cout << "在" << 寻2.印列(寻2.数) << "中寻" << 寻2.标 << endl;
    if (寻::壮插寻(寻2.数, 寻2.标, 位))
    {
        cout << 寻2.标 << "位于数列中第" << 位 << "位" << endl;
    }
    else
        cout << 寻2.标 << "不在数列中" << endl;
    cout << "共比标" << 寻2.比次 << "次" << endl;

    寻 寻b(数2, 标2);
    cout << "在" << 寻b.印列(寻b.数) << "中寻" << 寻b.标 << endl;
    if (寻::壮插寻(寻b.数, 寻b.标, 位))
    {
        cout << 寻b.标 << "位于数列中第" << 位 << "位" << endl;
    }
    else
        cout << 寻b.标 << "不在数列中" << endl;
    cout << "共比标" << 寻b.比次 << "次" << endl;

    cout << "\n--------------寻丄丅--------------" << endl;
    寻::寻丄丅(数3, 丄, 丅, 丄位, 丅位);
    cout << "在" << 寻::印列(数3) << "中" << endl;
    cout << "经" << 寻::比次 << "次比较后"
         << "丄[丄位]=" << 丄 << "[" << 丄位 << "],"
         << "丅[丅位]=" << 丅 << "[" << 丅位 << "]" << endl;

    cout << "\n--------------双寻--------------" << endl;
    寻::双寻(数3, 丄, 丅, 丄位, 丅位);
    cout << "在" << 寻::印列(数3) << "中" << endl;
    cout << "经" << 寻::比次 << "次比较后"
         << "丄[丄位]=" << 丄 << "[" << 丄位 << "],"
         << "丅[丅位]=" << 丅 << "[" << 丅位 << "]" << endl;



    cout << "\n--------------寻老二--------------" << endl;
    键型 老二;
    号型 老二号;
    bool 寻着 = 寻::寻老二(数3, 老二, 老二号);
    cout << "在" << 寻::印列(数3) << "中" << endl;
    cout << "经" << 寻::比次 << "次比较后"
         << "寻老二" << 老二 << "于第" << 老二号 << "号" << endl;

    列型 数4 = {12, 10, 5, 15, 18, 12, 4, 16};
    寻着 = 寻::寻老二(数4, 老二, 老二号);
    cout << "在" << 寻::印列(数4) << "中" << endl;
    cout << "经" << 寻::比次 << "次比较后"
         << "寻老二" << 老二 << "于第" << 老二号 << "号" << endl;


    cout << "\n--------------寻老二--------------" << endl;
    键型 老二;
    号型 老二号;
    bool 寻着 = 寻::寻老2(数3, 老二, 老二号);
    cout << "在" << 寻::印列(数3) << "中" << endl;
    cout << "经" << 寻::比次 << "次比较后"
         << "寻老二" << 老二 << "于第" << 老二号 << "号" << endl;

    列型 数4 = {12, 10, 5, 15, 18, 12, 4, 16};
    寻着 = 寻::寻老2(数4, 老二, 老二号);
    cout << "在" << 寻::印列(数4) << "中" << endl;
    cout << "经" << 寻::比次 << "次比较后"
         << "寻老二" << 老二 << "于第" << 老二号 << "号" << endl;


    cout << "\n--------------寻老几--------------" << endl;
    键型 老几 = 0;
    寻 寻3, 寻c;
    for (号型 几 = 0; 几 <= 7; 几++)
    {
        寻3.数 = 数3;
        寻3.比次 = 0;
        老几 = 寻::寻老几(寻3.数, 0, 寻3.数.size() - 1, 几);
        cout << "在" << 寻::印列(寻3.数) << "中" << endl;
        cout << "经" << 寻::比次 << "次比较后"
             << "寻老" << 几 + 1 << "得" << 老几 << endl;

        寻c.数 = 数4;
        寻c.比次 = 0;
        老几 = 寻::寻老几(寻c.数, 0, 寻c.数.size() - 1, 几);
        cout << "在" << 寻::印列(寻c.数) << "中" << endl;
        cout << "经" << 寻::比次 << "次比较后"
             << "寻老" << 几 + 1 << "得" << 老几 << endl;
    }



    cout << "\n--------------寻老几2--------------" << endl;
    键型 老几 = 0;
    寻 寻4, 寻5, 寻d;

    for (号型 几 = 0; 几 <= 7; 几++)
    {
        寻4.数 = 数3;
        寻4.比次 = 0;
        老几 = 寻::寻老几2(寻4.数, 0, 寻4.数.size() - 1, 几);
        cout << "在" << 寻::印列(寻4.数) << "中" << endl;
        cout << "经" << 寻::比次 << "次比较后"
             << "寻老" << 几 + 1 << "得" << 老几 << endl;

        寻5.数 = 数2;
        寻5.比次 = 0;
        老几 = 寻::寻老几2(寻5.数, 0, 寻5.数.size() - 1, 几);
        cout << "在" << 寻::印列(寻5.数) << "中" << endl;
        cout << "经" << 寻::比次 << "次比较后"
             << "寻老" << 几 + 1 << "得" << 老几 << endl;

        寻d.数 = 数4;
        寻d.比次 = 0;
        老几 = 寻::寻老几2(寻d.数, 0, 寻d.数.size() - 1, 几);
        cout << "在" << 寻::印列(寻d.数) << "中" << endl;
        cout << "经" << 寻::比次 << "次比较后"
             << "寻老" << 几 + 1 << "得" << 老几 << endl;
    }
#endif

    cout << "\n--------------寻老几3--------------" << endl;
    键型 老几 = 0;
    寻 寻6, 寻7, 寻e;
    号型 几 = 0;
    for (几 = 0; 几 <= 9; 几++)
    {
        寻6.数 = 数3;
        寻6.比次 = 0;
        老几 = 寻::寻老几3(寻6.数, 0, 寻6.数.size() - 1, 几);
        cout << "在" << 寻::印列(寻6.数) << "中" << endl;
        cout << "经" << 寻::比次 << "次比较后"
             << "寻老" << 几 + 1 << "得" << 老几 << endl;
    }
    cout << endl;

    for (几 = 0; 几 <= 9; 几++)
    {
        寻7.数 = 数2;
        寻7.比次 = 0;
        老几 = 寻::寻老几3(寻7.数, 0, 寻7.数.size() - 1, 几);
        cout << "在" << 寻::印列(寻7.数) << "中" << endl;
        cout << "经" << 寻::比次 << "次比较后"
             << "寻老" << 几 + 1 << "得" << 老几 << endl;
    }
    cout << endl;

    for (几 = 0; 几 <= 7; 几++)
    {
        寻e.数 = 数4;
        寻e.比次 = 0;
        老几 = 寻::寻老几3(寻e.数, 0, 寻e.数.size() - 1, 几);
        cout << "在" << 寻::印列(寻e.数) << "中" << endl;
        cout << "经" << 寻::比次 << "次比较后"
             << "寻老" << 几 + 1 << "得" << 老几 << endl;
    }
}