#include <iostream>
#include <string>
#include <sstream>
#include <vector>
#include <algorithm>
#include <iterator>
#include <cmath>

using namespace std;

typedef int 号型;
typedef int 键型;
typedef vector<键型> 列型;

// 用于链式分并排序
typedef struct
{
    键型 值;
    号型 翌号; // 存被指节之列号
} 节;

// 用于基排序
struct 基节
{
    string 值;
    基节 *翌;
};
typedef 基节 *基指;

// 用于堆排序
struct 堆
{
    vector<键型> 列;
    int 夵;
};

class 排序
{
public:
    列型 数;

public:
    排序(const 列型 &数) : 数(数)
    {
    }

    // 课本页289算法7.1
    /* 插排法：
    默认升序
    列含左侧已排及右侧未排两部分
    将未排元素插入已排部分
    */
    static void 插排(int 列长, 键型 数[])
    {
        号型 待插号, 插位;
        键型 待插元;

        for (待插号 = 1; 待插号 <= 列长 - 1; 待插号++)
        {
            待插元 = 数[待插号];
            插位 = 待插号 - 1;
            while (插位 >= 0 && 数[插位] > 待插元)
            {
                数[插位 + 1] = 数[插位]; // 右移大于待插元的数
                插位--;
            }
            数[插位 + 1] = 待插元;
        }
    }

    static void 插排(列型 &数)
    {
        int 列长 = 数.size();
        号型 待插号, 插位;
        键型 待插元;

        for (待插号 = 1; 待插号 <= 列长 - 1; 待插号++)
        {
            待插元 = 数[待插号];
            插位 = 待插号 - 1;
            while (插位 >= 0 && 数[插位] > 待插元)
            {
                数[插位 + 1] = 数[插位]; // 右移大于待插元的数
                插位--;
            }
            数[插位 + 1] = 待插元;
        }
    }

    // 课本页8算法1.3
    /* 换排法:
    默认升序
    左侧排好右侧待排
    每次把待排部分左元与其余更小元换位
    遍历其余元后待排最小元被换至待排部分左首
    每次比较若有更小则交换
    */
    static void 换排(int 列长, 键型 数[])
    {
        号型 前, 后;
        for (前 = 0; 前 <= 列长 - 1; 前++)
            for (后 = 前 + 1; 后 <= 列长 - 1; 后++)
            {
                if (数[后] < 数[前])
                {
                    // 交换 数[后], 数[前]
                    swap(数[后], 数[前]);
                }
            }
    }

    static void 换排(列型 &数)
    {
        int 列长 = 数.size();
        号型 前, 后;
        for (前 = 0; 前 <= 列长 - 1; 前++)
            for (后 = 前 + 1; 后 <= 列长 - 1; 后++)
            {
                if (数[后] < 数[前]) // 边比边换
                {
                    // 交换 数[后], 数[前]
                    swap(数[后], 数[前]);
                }
            }
    }

    // 课本页292算法7.2
    /* 选排法:
    默认升序
    左侧排好右侧待排
    每次把待排部分左元与其余最小元换位
    */
    static void 选排(列型 &数)
    {
        int 列长 = 数.size();
        号型 前, 后, 丅;
        for (前 = 0; 前 <= 列长 - 1; 前++)
        {
            丅 = 前;
            for (后 = 前 + 1; 后 <= 列长 - 1; 后++)
            {
                if (数[后] < 数[丅]) // 比完再换
                {
                    丅 = 后;
                }
            }
            swap(数[丅], 数[前]);
        }
    }

    // 课本页58算法2.2
    /* 分并法:
    默认升序
    先分后并,边并边排
    */

    static void 并排(const 列型 &甲, const 列型 &乙, 列型 &并)
    {
        号型 j = 0, y = 0, b = 0;
        int 甲长 = 甲.size(), 乙长 = 乙.size();
        while (j < 甲长 && y < 乙长)
        {
            if (甲[j] < 乙[y])
            {
                并[b] = 甲[j];
                j++;
            }
            else
            {
                并[b] = 乙[y];
                y++;
            }
            b++;
        }
        if (j >= 甲长) // 甲先并完, 乙有剩
            copy_n(乙.begin() + y, 乙长 - y, 并.begin() + b);
        else // 乙先并完, 甲有剩
            copy_n(甲.begin() + j, 甲长 - j, 并.begin() + b);
    }

    static void 分并(列型 &数)
    {
        int 列长 = 数.size();
        if (列长 > 1)
        { // 先分
            号型 中点 = 列长 / 2;
            列型 左列, 右列;
            copy(数.begin(), 数.begin() + 中点, back_inserter(左列));
            copy(数.begin() + 中点, 数.end(), back_inserter(右列));
            分并(左列);
            分并(右列);
            // 后并
            并排(左列, 右列, 数);
        }
    }

    // 课本62页2.4算法
    /* 分并排序算法 2

    */
    static void 并排2(列型 &数, 列型 &内, 号型 左号, 号型 中点, 号型 右号)
    {
        号型 左步, 右步, 并步;

        左步 = 左号;
        右步 = 中点 + 1;
        并步 = 左号;
        while (左步 <= 中点 && 右步 <= 右号)
        {
            if (数[左步] < 数[右步])
            {
                内[并步] = 数[左步];
                左步++;
            }
            else
            {
                内[并步] = 数[右步];
                右步++;
            }
            并步++;
        }
        if (左步 > 中点) // 左侧先并完,右侧有余
        {
            copy_n(数.begin() + 右步, 右号 - 右步 + 1, 内.begin() + 并步);
        }
        else
        { // 右侧先并完, 左侧有余
            copy_n(数.begin() + 左步, 中点 - 左步 + 1, 内.begin() + 并步);
        }
        cout << "左号" << 左号 << "中点" << 中点 << "右号" << 右号 << endl;
        cout << "数:" << 印列(数) << "内:" << 印列(内) << endl;
        copy_n(内.begin() + 左号, 右号 - 左号 + 1, 数.begin() + 左号);
    }

    static void 分合(列型 &数, 列型 &内, 号型 左号, 号型 右号)
    {
        号型 中点;
        if (左号 < 右号)
        {
            // 先分
            中点 = (左号 + 右号) / 2;
            分合(数, 内, 左号, 中点);
            分合(数, 内, 中点 + 1, 右号);
            // 后并
            并排2(数, 内, 左号, 中点, 右号);
        }
    }

    static void 分并2(列型 &数)
    {
        号型 左号 = 0, 右号 = 数.size() - 1;
        列型 内(数.size(), 0);
        分合(数, 内, 左号, 右号);
    }

    // 课本298页算法7.3
    /* 动态规划
    第1层每2数并排, 子列长=1
    第2层将并好的2数子列两两并排, 子列长=2
    第3层将并好的4数子列两两并排, 子列长=4
    ...
    直至并完
     */
    static void 轮换并排(列型 &数, 列型 &内, 号型 左号, 号型 中点, 号型 右号)
    {
        号型 左步, 右步, 并步;

        左步 = 左号;
        右步 = 中点 + 1;
        并步 = 左号;
        while (左步 <= 中点 && 右步 <= 右号)
        {
            if (数[左步] < 数[右步])
            {
                内[并步] = 数[左步];
                左步++;
            }
            else
            {
                内[并步] = 数[右步];
                右步++;
            }
            并步++;
        }
        if (左步 > 中点) // 左侧先并完,右侧有余
        {
            copy_n(数.begin() + 右步, 右号 - 右步 + 1, 内.begin() + 并步);
        }
        else
        { // 右侧先并完, 左侧有余
            copy_n(数.begin() + 左步, 中点 - 左步 + 1, 内.begin() + 并步);
        }
        cout << 印列(数) << " --> " << 印列(内) << endl;
        // copy_n(内.begin() + 左号, 右号 - 左号 + 1, 数.begin() + 左号);
    }
    static void 并排3(列型 &数, 列型 &内, 号型 左号, 号型 中点, 号型 右号, bool 数至内)
    {
        if (数至内)
        {
            轮换并排(数, 内, 左号, 中点, 右号);
        }
        else
        {
            轮换并排(内, 数, 左号, 中点, 右号);
        }
    }

    static void 分并3(列型 &数)
    {
        int 列长 = 数.size();
        int 层数 = (int)ceil(log2(列长));
        int 幂2列长 = pow(2, 层数);

        号型 左号, 中号, 右号;
        列型 内(列长, 0);
        bool 数至内 = true;

        int 子列长 = 1;

        int 层 = 层数;
        while (层--)
        {
            cout << "\n层:" << 层数 - 层 << "子列长: " << 子列长 << endl;
            for (左号 = 0; 左号 < 幂2列长 - 2 * 子列长 + 1 && 左号 < 列长; 左号 += 2 * 子列长)
            {
                中号 = 左号 + 子列长 - 1;
                右号 = min(左号 + 2 * 子列长 - 1, 列长 - 1);

                if (中号 > 右号)
                    break;
                cout << "左号" << 左号 << "中号" << 中号 << "右号" << 右号 << endl;
                并排3(数, 内, 左号, 中号, 右号, 数至内);
            }
            数至内 = !数至内;
            子列长 *= 2;
        }
    }

    // 课本300页算法7.4
    /* 并排
    采用链存储及排序
    */
    static void 分并4(列型 &数)
    {
        号型 左号 = 0, 右号 = 数.size() - 1, 并首号 = 0;
        vector<节> 链(数.size());

        for (int 号 = 0; 号 < 数.size(); 号++)
        {
            链[号].值 = 数[号];
            链[号].翌号 = -1;
        }

        排链(链, 左号, 右号, 并首号);

        // 取排好的序列
        vector<键型> 内;
        while (并首号 != -1)
        {
            内.push_back(链[并首号].值);
            并首号 = 链[并首号].翌号;
        }
        // 复制回去
        copy_n(内.begin(), 内.size(), 数.begin());
    }

    static void 排链(vector<节> &链, 号型 左号, 号型 右号, 号型 &并首号)
    {
        号型 中号, 链号1, 链号2;
        if (左号 == 右号)
        {
            并首号 = 左号;
            链[并首号].翌号 = -1;
        }
        else
        {
            中号 = (左号 + 右号) / 2;
            排链(链, 左号, 中号, 链号1);
            排链(链, 中号 + 1, 右号, 链号2);
            并链(链, 链号1, 链号2, 并首号);
        }
    }

    static void 并链(vector<节> &链, 号型 链号1, 号型 链号2, 号型 &并首号)
    {
        号型 并尾号;
        // 链首
        if (链[链号1].值 < 链[链号2].值)
        {
            并首号 = 链号1;
            链号1 = 链[链号1].翌号;
        }
        else
        {
            并首号 = 链号2;
            链号2 = 链[链号2].翌号;
        }

        并尾号 = 并首号;
        while (链号1 != -1 && 链号2 != -1) // 链尾节翌号为-1
        {
            if (链[链号1].值 < 链[链号2].值) // 小节接至并链尾
            {
                链[并尾号].翌号 = 链号1;
                并尾号 = 链号1;
                链号1 = 链[链号1].翌号;
            }
            else
            {
                链[并尾号].翌号 = 链号2;
                并尾号 = 链号2;
                链号2 = 链[链号2].翌号;
            }
        }
        if (链号1 == -1) // 链1并完
        {
            链[并尾号].翌号 = 链号2;
        }
        else
        {
            链[并尾号].翌号 = 链号1;
        }
    }

    // 课本329页图7.14
    /* 基排1 (基=10,十进制)
    按数位分群排序. 假设被排数位数都相同.
    按数位从左往右分并
    */
    static void 基排1(列型 &数)
    {
        int 位数 = 0;
        基指 主 = new 基节[数.size()];

        for (号型 号 = 0; 号 < 数.size(); 号++)
        {
            主[号].值 = to_string(数[号]);
            if (位数 < 主[号].值.length())
                位数 = 主[号].值.length(); // 记录最多位数
            主[号].翌 = ((号 == 数.size() - 1) ? nullptr : &主[号 + 1]);
        }

        cout << "初始主群:" << 印群(主) << endl;
        // 不足位前补〇, 闹着玩.
        for (号型 号 = 0; 号 < 数.size(); 号++)
        {
            string 补〇(位数 - 主[号].值.size(), '0');
            主[号].值 = 补〇 + 主[号].值;
        }
        cout << "补〇主群:" << 印群(主) << endl;

        数.clear();
        分到底(主, 0, 位数, 数);
    }

    static void 分到底(基指 &主, int 位, int 位数, 列型 &序)
    {
        if (主 == nullptr /* || 主->翌 == nullptr */ || 位 == 位数)
        {
            // if (主 != nullptr && 主->翌 == nullptr)
            //     序.push_back(stoi(主->值));

            return;
        }

        vector<基指> 分(10, nullptr);

        号型 号;
        基指 指, 附;
        指 = 主;
        while (指 != nullptr)
        {
            // 从左往右依位分群
            号 = 指->值[位] - '0'; // 位号串号都从左往右数,始于〇
            附 = 指;
            指 = 指->翌;
            附尾(分[号], 附);
        }

        cout << "--------第" << 位 << "位分群---------" << endl;
        for (号 = 0; 号 <= 9; 号++)
        {
            cout << 号 << ":" << 印群(分[号]) << endl;
            if (位 == 位数 - 1 && 分[号] != nullptr)
            {
                // 序.push_back(stoi(分[号]->值)); // 可用于移除重复数

                // 有重复数
                基指 指 = 分[号];
                while (指 != nullptr)
                {
                    序.push_back(stoi(指->值));
                    指 = 指->翌;
                }
            }
        }

        for (号 = 0; 号 <= 9; 号++)
            分到底(分[号], 位 + 1, 位数, 序);
    }

    // 课本329页算法7.6
    /* 基排 (基=10,十进制)
    按数位分群排序. 假设被排数位数都相同.
    按数位从右往左分并
    */
    static void 基排(列型 &数)
    {
        int 位数 = 0;
        基指 主 = new 基节[数.size()];

        for (号型 号 = 0; 号 < 数.size(); 号++)
        {
            主[号].值 = to_string(数[号]);
            if (位数 < 主[号].值.length())
                位数 = 主[号].值.length(); // 记录最多位数
            主[号].翌 = ((号 == 数.size() - 1) ? nullptr : &主[号 + 1]);
        }

        cout << "初始主群:" << 印群(主) << endl;
        // 不足位前补〇, 闹着玩.
        for (号型 号 = 0; 号 < 数.size(); 号++)
        {
            string 补〇(位数 - 主[号].值.size(), '0');
            主[号].值 = 补〇 + 主[号].值;
        }
        cout << "补〇主群:" << 印群(主) << endl;
        分并群(主, 位数);

        // 把排序好的数复制回去
        号型 号;
        基指 指 = 主;
        while (指 != nullptr)
        {

            数[号++] = stoi(指->值);
            指 = 指->翌;
        }
    }
    static void 分并群(基指 &主, int 位数)
    {
        号型 位;
        vector<基指> 分(10, nullptr);

        for (位 = 0; 位 < 位数; 位++)
        {
            cout << "---------第" << 位 << "位----------" << endl;
            分群(分, 主, 位, 位数);
            并群(分, 主);
        }
    }

    static void 分群(vector<基指> &分, 基指 &主, 号型 位, int 位数)
    {
        号型 号;
        基指 指, 附;

        for (号 = 0; 号 <= 9; 号++)
            分[号] = nullptr;

        指 = 主;
        while (指 != nullptr)
        {
            // 从右往左依位分群
            号 = 指->值[位数 - 1 - 位] - '0'; // 位号从右往左数,始于〇, 而串号从左往右数
            附 = 指;
            指 = 指->翌;
            附尾(分[号], 附);
        }

        cout << "分群:" << endl;
        for (号 = 0; 号 <= 9; 号++)
        {
            cout << 号 << ":" << 印群(分[号]) << endl;
        }
    }

    static void 并群(vector<基指> &分, 基指 &主)
    {
        号型 号;
        基指 指;

        主 = nullptr;

        for (号 = 0; 号 <= 9; 号++)
        {
            if (分[号] != nullptr)
            {
                if (主 == nullptr)
                {
                    主 = 分[号];
                    指 = 主;
                }
                else
                {
                    while (指->翌 != nullptr)
                    {
                        指 = 指->翌;
                    }
                    指->翌 = 分[号];
                }
            }
        }
        cout << "并群: " << 印群(主) << endl;
    }

    static void 附尾(基指 &尾, 基指 &附)
    {
        基指 指;

        if (尾 == nullptr)
        {
            尾 = 附;
        }
        else
        {
            指 = 尾;
            while (指->翌 != nullptr)
            {
                指 = 指->翌;
            }
            指->翌 = 附;
        }

        附->翌 = nullptr;
    }

    static string 印群(const 基指 &群)
    {
        stringstream ss;
        基指 前 = 群;

        ss << "(";
        if (群 != nullptr)
        {
            while (前->翌 != nullptr)
            {
                ss << 前->值 << "->";
                前 = 前->翌;
            }
            ss << 前->值;
        }
        ss << ")";
        return ss.str();
    }

    // 课本310页算法7.5
    /* 堆排
     */

    static void 堆排(列型 &数)
    {
        列型 待列(数);
        待列.insert(待列.begin(), 0); // 浪费0号
        堆 某堆{待列, (int)数.size()};
        造堆(某堆);
        堆序(某堆, 待列);
        copy_n(待列.begin() + 1, 数.size(), 数.begin());
    }

    static void 沉键(堆 &某堆, 号型 键号)
    {
        号型 父号, 大子号;
        键型 沉键;
        bool 得靶位;

        沉键 = 某堆.列[键号];
        父号 = 键号;
        得靶位 = false;

        while (2 * 父号 <= 某堆.夵 && !得靶位)
        {
            if (2 * 父号 < 某堆.夵 && 某堆.列[2 * 父号] < 某堆.列[2 * 父号 + 1])
            {
                大子号 = 2 * 父号 + 1;
            }
            else
            {
                大子号 = 2 * 父号;
            }

            if (沉键 < 某堆.列[大子号])
            {
                某堆.列[父号] = 某堆.列[大子号];
                父号 = 大子号;
            }
            else
            {
                得靶位 = true;
            }
        }
        某堆.列[父号] = 沉键;

        stringstream ss;
        印堆(某堆, ss, 1);
        cout << "沉键↓" << ss.str() << endl;
    }

    static 键型 取根(堆 &某堆)
    {
        键型 根;
        根 = 某堆.列[1];
        某堆.列[1] = 某堆.列[某堆.夵]; // 移堆尾键至根
        某堆.列[某堆.夵] = 0;          // 清堆尾增强视感
        某堆.夵 -= 1;
        cout << "---------取根沉键----------" << endl;
        沉键(某堆, 1);
        return 根;
    }

    // 取堆内数放入序列
    static void 堆序(堆 &某堆, vector<键型> &序)
    {
        号型 号;
        int 总键数 = 某堆.列.size() - 1;
        fill(序.begin(), 序.end(), 0);
        for (号 = 总键数; 号 >= 1; 号--)
        {
            cout << "----------堆序取根-----------" << endl;
            序[号] = 取根(某堆);
            cout << "堆->:" << 印列(某堆.列) << endl;
            cout << "序<-:" << 印列(序) << endl;
        }
    }

    static void 印堆(const 堆 &某堆, stringstream &ss, 号型 号)
    {
        if (2 * 号 == 某堆.夵 && 2 * 号 + 1 > 某堆.夵)
        {
            ss << 某堆.列[号] << "(" << 某堆.列[2 * 号] << ")";
            return;
        }
        if (2 * 号 < 某堆.夵 && 2 * 号 + 1 == 某堆.夵)
        {
            ss << 某堆.列[号] << "(" << 某堆.列[2 * 号] << "," << 某堆.列[2 * 号 + 1] << ")";
            return;
        }
        if (2 * 号 < 某堆.夵)
        {
            ss << 某堆.列[号] << "(";
            印堆(某堆, ss, 2 * 号);
            ss << ",";
            印堆(某堆, ss, 2 * 号 + 1);
            ss << ")";
            return;
        }
        if (某堆.夵 == 1 || 号 < 某堆.夵)
        {
            ss << 某堆.列[号];
            return;
        }
    }

    static void 造堆(堆 &某堆)
    {
        号型 号;
        int 总键数 = 某堆.列.size() - 1;
        for (号 = 总键数 / 2; 号 >= 1; 号--)
        {
            cout << "----------造堆沉键-----------" << endl;
            沉键(某堆, 号);
            cout << "造堆:" << 印列(某堆.列) << endl;
        }
    }

    // 课本65页算法2.6
    /* 快排
    先分后排
    划界: 界左数小于界, 界右数大于等于界
    */
    static void 划(列型 &数, 号型 左号, 号型 右号, 号型 &界号)
    {
        号型 步, 界步;
        键型 界数 = 数[左号]; // 取左数为界数
        界步 = 左号;

        for (步 = 左号 + 1; 步 <= 右号; 步++)
        {
            if (数[步] < 界数)
            {
                界步++;
                swap(数[界步], 数[步]);
                cout << "寻(" << 界数 << ")" << 印列(数) << endl;
            }
        }
        界号 = 界步; // 定界于最后交换位
        swap(数[左号], 数[界号]);
        cout << "定(" << 界数 << ")" << 印列(数) << endl;
        cout << "划(" << 界数 << ")" << 印列(数, 左号, 界号 - 1) << "|" << 数[界号] << "|" << 印列(数, 界号 + 1, 右号) << endl;
    }

    static void 速排(列型 &数, 号型 左号, 号型 右号)
    {
        号型 界号;
        if (右号 > 左号)
        {
            划(数, 左号, 右号, 界号);
            速排(数, 左号, 界号 - 1);
            速排(数, 界号 + 1, 右号);
        }
    }

    static void 快排(列型 &数)
    {
        号型 左号 = 0, 右号 = 数.size() - 1;
        速排(数, 左号, 右号);
    }

    // 课本332页题8: 分段插排
    static void 分段插排(列型 &数)
    {
        //  段长集=[列长/2, 列长/4,...,1]
        int 列长 = 数.size();
        int 段长, 左步, 右步, 间;
        vector<int> 段长集;

        for (段长 = 列长 / 2; 段长 > 0; 段长 /= 2)
        {
            段长集.push_back(段长);
            for (右步 = 段长; 右步 < 列长; 右步++)
            {
                间 = 数[右步];
                for (左步 = 右步; 左步 >= 段长 && 间 < 数[左步 - 段长]; 左步 -= 段长)
                    数[左步] = 数[左步 - 段长];
                数[左步] = 间;
            }
        }
        cout << "分段插排段长集:" << 印列(段长集) << endl;
    }

    static void 分段插排0(列型 &数)
    {
        int 列长 = 数.size();
        int 左步, 右步, 间;
        vector<int> 段长集 = {1};

        cout << "分段插排0段长集:" << 印列(段长集) << endl;

        for (int 段长 : 段长集)
        {
            for (右步 = 段长; 右步 < 列长; 右步++)
            {
                间 = 数[右步];
                for (左步 = 右步; 左步 >= 段长 && 间 < 数[左步 - 段长]; 左步 -= 段长)
                    数[左步] = 数[左步 - 段长];
                数[左步] = 间;
            }
        }
    }

    static void 分段插排1(列型 &数)
    {
        int 列长 = 数.size();
        int 左步, 右步, 间;

        // 分法=1, 段长集=[1,3,7,...,2^k-1]
        vector<int> 段长集;
        for (int 段长 = 2; 段长 < 列长 + 1; 段长 *= 2)
        {
            段长集.push_back(段长 - 1);
        }
        reverse(段长集.begin(), 段长集.end());
        cout << "分段插排1段长集:" << 印列(段长集) << endl;

        for (int 段长 : 段长集)
        {
            for (右步 = 段长; 右步 < 列长; 右步++)
            {
                间 = 数[右步];
                for (左步 = 右步; 左步 >= 段长 && 间 < 数[左步 - 段长]; 左步 -= 段长)
                    数[左步] = 数[左步 - 段长];
                数[左步] = 间;
            }
        }
    }

    static void 分段插排2(列型 &数)
    {
        int 列长 = 数.size();
        int 左步, 右步, 间;

        // 分法=2, 段长集=[1,2,3,4,6,...,2^m3^n]
        // 咋造此集?
        vector<int> 段长集;
        for (int 段长 = 1, i = 0; 段长 < 列长; 段长 *= (i % 2 == 0 ? 2 : 3), i++)
        {
            段长集.push_back(段长);
        }
        reverse(段长集.begin(), 段长集.end());
        cout << "分段插排2段长集:" << 印列(段长集) << endl;

        for (int 段长 : 段长集)
        {
            for (右步 = 段长; 右步 < 列长; 右步++)
            {
                间 = 数[右步];
                for (左步 = 右步; 左步 >= 段长 && 间 < 数[左步 - 段长]; 左步 -= 段长)
                    数[左步] = 数[左步 - 段长];
                数[左步] = 间;
            }
        }
    }

    // 排3个不同的数: 3!
    static void 排3(列型 &数)
    {
        // if .. else if.. else if .. else
        // = if .. else {if.. else {if .. else}}
        键型 a = 数[0], b = 数[1], c = 数[2];
        if (a < b)
            if (b < c)
                数 = {a, b, c};
            else
            {
                if (a < c) // c < b
                    数 = {a, c, b};
                else // c < a && c < b && a < b
                    数 = {c, a, b};
            }

        else // b<a
            if (c < b)
                数 = {c, b, a};
            else if (a < c) // b < c && b < a
                数 = {b, a, c};
            else // c < a && b < c && b < a
                数 = {b, c, a};
    }

    // 印列

    static string 印列(int 列长, 键型 数[])
    {
        stringstream ss;
        ss << "[";
        for (号型 号 = 0; 号 <= 列长 - 1; 号++)
        {
            ss << 数[号] << (号 == 列长 - 1 ? "" : ",");
        }
        ss << "]";
        return ss.str();
    }

    static string 印列(const 列型 &数)
    {
        int 列长 = 数.size();
        stringstream ss;
        ss << "[";
        for (号型 号 = 0; 号 <= 列长 - 1; 号++)
        {
            ss << 数[号] << (号 == 列长 - 1 ? "" : ",");
        }
        ss << "]";
        return ss.str();
    }
    static string 印列(const 列型 &数, const 号型 起, const 号型 止)
    {
        stringstream ss;
        ss << "[";
        for (号型 号 = 起; 号 <= 止; 号++)
        {
            ss << 数[号] << (号 == 止 ? "" : ",");
        }
        ss << "]";
        return ss.str();
    }
};

int main()
{
#if 0    
    列型 数 = {3, 9, 8, 4, 3, 7, 2, 0, 1};

    排序 排1(数);
    cout << "插入排序:" << endl;
    cout << "排序前:" << 排序::印列(排1.数) << endl;
    排序::插排(排1.数);
    cout << "排序后:" << 排序::印列(排1.数) << endl;

    排序 排2(数);
    cout << "\n换位排序:" << endl;
    cout << "排序前:" << 排序::印列(排2.数) << endl;
    排序::换排(排2.数);
    cout << "排序后:" << 排序::印列(排2.数) << endl;

    排序 排3(数);
    cout << "\n换丅排序:" << endl;
    cout << "排序前:" << 排序::印列(排3.数) << endl;
    排序::选排(排3.数);
    cout << "排序后:" << 排序::印列(排3.数) << endl;

    排序 排4(数);
    cout << "\n分并排序:" << endl;
    cout << "排序前:" << 排序::印列(排4.数) << endl;
    排序::分并(排4.数);
    cout << "排序后:" << 排序::印列(排4.数) << endl;

    排序 排5(数);
    cout << "\n分并2排序:" << endl;
    cout << "排序前:" << 排序::印列(排5.数) << endl;
    排序::分并2(排5.数);
    cout << "排序后:" << 排序::印列(排5.数) << endl;

    排序 排6(数);
    cout << "\n快速排序:" << endl;
    cout << "排序前:" << 排序::印列(排6.数) << endl;
    排序::快排(排6.数);
    cout << "排序后:" << 排序::印列(排6.数) << endl;

    排序 排7(数);
    cout << "\n分段插排:" << endl;
    cout << "排序前:" << 排序::印列(排7.数) << endl;
    排序::分段插排(排7.数);
    cout << "排序后:" << 排序::印列(排7.数) << endl;

    排序 排8(数);
    cout << "\n分段插排1:" << endl;
    cout << "排序前:" << 排序::印列(排8.数) << endl;
    排序::分段插排1(排8.数);
    cout << "排序后:" << 排序::印列(排8.数) << endl;

    排序 排9(数);
    cout << "\n分段插排1:" << endl;
    cout << "排序前:" << 排序::印列(排9.数) << endl;
    排序::分段插排2(排9.数);
    cout << "排序后:" << 排序::印列(排9.数) << endl;

    排序 排a(数);
    cout << "\n分段插排0:" << endl;
    cout << "排序前:" << 排序::印列(排a.数) << endl;
    排序::分段插排0(排a.数);
    cout << "排序后:" << 排序::印列(排a.数) << endl;

    排序 排b(数);
    cout << "\n分并排序3:" << endl;
    cout << "排序前:" << 排序::印列(排b.数) << endl;
    排序::分并3(排b.数);
    cout << "排序后:" << 排序::印列(排b.数) << endl;

    排序 排c(数);
    cout << "\n分并排序4:" << endl;
    cout << "排序前:" << 排序::印列(排c.数) << endl;
    排序::分并4(排c.数);
    cout << "排序后:" << 排序::印列(排c.数) << endl;

    // 课本327页图714
    排序 排d({239, 234, 879, 878, 123, 358, 416, 317, 137, 225});
    cout << "\n基排:" << endl;
    cout << "排序前:" << 排序::印列(排d.数) << endl;
    排序::基排(排d.数);
    cout << "排序后:" << 排序::印列(排d.数) << endl;

    排序 排e({29, 34, 879, 87, 3, 358, 46, 317, 7, 225});
    cout << "\n基排:" << endl;
    cout << "排序前:" << 排序::印列(排e.数) << endl;
    排序::基排(排e.数);
    cout << "排序后:" << 排序::印列(排e.数) << endl;   

    排序 排f({29, 34, 879, 87, 3, 358, 46, 317, 7, 225, 239, 234, 878, 123, 416, 137});
    cout << "\n基排:" << endl;
    cout << "排序前:" << 排序::印列(排f.数) << endl;
    排序::基排(排f.数);
    cout << "排序后:" << 排序::印列(排f.数) << endl;


    排序 排g({239, 234, 879, 878, 123, 358, 416, 317, 137, 225});
    cout << "\n基排1:" << endl;
    cout << "排序前:" << 排序::印列(排g.数) << endl;
    排序::基排1(排g.数);
    cout << "排序后:" << 排序::印列(排g.数) << endl;

    排序 排h({29, 34, 879, 87, 3, 358, 46, 317, 7, 225, 239, 234, 878, 123, 416, 137, 0, 22, 77, 88, 33, 55, 44, 878});
    cout << "\n基排1:" << endl;
    cout << "排序前:" << 排序::印列(排h.数) << endl;
    排序::基排1(排h.数);
    cout << "排序后:" << 排序::印列(排h.数) << endl;


    排序 排i({16, 11, 14, 18, 12, 19, 17, 20, 25, 30});
    cout << "\n堆排:" << endl;
    cout << "排序前:" << 排序::印列(排i.数) << endl;
    排序::堆排(排i.数);
    cout << "排序后:" << 排序::印列(排i.数) << endl;
#endif

}