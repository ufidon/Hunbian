#include <stdio.h>
#include <string.h>
#include <limits.h>

void 分段排序(int 列[], int 列长)
{
    int 段长, 内号, 外号, 数;
    for(段长 = 列长/2; 段长>0; 段长 /= 2)
        for(内号=段长; 内号 < 列长; 内号++)
            for(外号=内号-段长; 外号>=0 && 列[外号]>列[外号+段长]; 外号-=段长){
                数 = 列[外号];
                列[外号] = 列[外号+段长];
                列[外号+段长] = 数;
            }
}

void 印列(int 列[], int 列长)
{
    int 号;
    printf("[");
    for(号=0; 号<列长; 号++)
        printf("%d%s", 列[号], 号==列长-1?"]\n":",");
}

void 逆串(char 串[])
{
    int 字, 左号, 右号;
    for ( 左号 = 0, 右号 = strlen(串)-1; 左号 < 右号; 左号++, 右号--)
    {
        字 = 串[左号];
        串[左号] = 串[右号];
        串[右号] = 字;
    }    
}

void 数转串(int 数, char 串[])
{
    int 号, 正负;

    if((正负 = 数) <0) 数 = -数; // 记录正负号并把负数变正

    号 = 0;
    do
    {
        串[号++] = 数%10 + '0';
    } while ((数 /= 10) >0);
    if(正负 < 0) 串[号++] = '-';
    串[号] = '\0';
    逆串(串);
}

int main(int argc, char const *argv[])
{
    int 列[] = {1,6,0,2,1,7,6,6,3,4}, 列长 = 10;
    int 数=-1602176634;
    char 串1[20]; // 要够长

    printf("排序前: "); 印列(列, 列长);
    分段排序(列, 列长);
    printf("排序后: "); 印列(列, 列长);

    char 串2[] = "hun dun chu kai, qian kun shi dian.";
    printf("原串: \"%s\"\n", 串2);
    逆串(串2);
    printf("逆串: \"%s\"\n", 串2);

    数转串(数, 串1);
    printf("数转串: %d -> \"%s\"\n", 数, 串1);

    return 0;
}

/*练习
3. 写函数 展(char 缩[], char 全[]) 将缩写展全写: a-f展成abcdef, c-g3-7展成cdefg34567, 
    -dh-k展成abcdhijk, x-展成xyz, -3展成0123, 7-展成789等等.
4. 怎样找到系统所用的最小负整数 -(2^(sizeof(int)*8-1)), 即int所能表示的最小负数? 上述数转串能转换最小负整数吗? 如果不能, 如何改进它?
5. 写函数 整转基(int 数, char 串[], int 基) 把整数转成以基表示的串: 基=2即二进制串, 基=16即十六进制串.
6. 设计新版 数转串(int 数, char 串[], int 长), 长为最小串长, 所得串长不够则左侧补空格. 如长=6, 数=3, 则串为"     3", 左补5个空格.
*/
