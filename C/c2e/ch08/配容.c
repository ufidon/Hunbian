#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define _调试
void 印调(char *格式, ...);

typedef long _对齐;

union _头
{
    struct
    {
        union _头 *翌;
        unsigned 夵;
    } 信;
    _对齐 勿用;
};

typedef union _头 头;

static 头 库;
static 头 *库首 = NULL;

void 释(void *);
static 头 *更多容器(unsigned 器数);

void *配(unsigned 容量)
{
    头 *当, *前;
    unsigned 节数;

    节数 = (容量 + sizeof(头) - 1) / sizeof(头) + 1;
    if ((前 = 库首) == NULL)
    {
        库.信.翌 = 库首 = 前 = &库;
        库.信.夵 = 0;
        印调("配0: 当=%p 当.信.夵=%d 当.信.翌=%p", (void *)当, 当->信.夵, (void *)当->信.翌);
    }

    for (当 = 前->信.翌;; 前 = 当, 当 = 当->信.翌)
    {
        if (当->信.夵 >= 节数)
        {
            if (当->信.夵 == 节数)
                前->信.翌 = 当->信.翌;
            else
            {
                当->信.夵 -= 节数;
                当 += 当->信.夵;
                当->信.夵 = 节数;
            }

            库首 = 前;
            印调("配1: 当=%p 当.信.夵=%d 当.信.翌=%p", (void *)当, 当->信.夵, (void *)当->信.翌);

            void *出 = (void *)(当 + 1);
            印调("配: 出=%p", 出);
            return 出;
        }
        if (当 == 库首)
        {
            if ((当 = 更多容器(节数)) == NULL)
                return NULL;

            印调("配-1: 建库或扩容.");
            印调("配-1: 当=%p 当.信.夵=%d 当.信.翌=%p", (void *)当, 当->信.夵, (void *)当->信.翌);
        }
    }
}

#define 丅节数 1024

static 头 *更多容器(unsigned 器数)
{
    char *增;
    头 *增头;

    if (器数 < 丅节数)
        器数 = 丅节数;

    增 = sbrk(器数 * sizeof(头));

    if (增 == (char *)-1)
        return NULL;

    增头 = (头 *)增;
    增头->信.夵 = 器数;
    释((void *)(增头 + 1));

    return 库首;
}

void 释(void *废)
{
    头 *废首, *当;

    废首 = (头 *)废 - 1;
    for (当 = 库首; !(废首 > 当 && 废首 < 当->信.翌); 当 = 当->信.翌)
        if (当 >= 当->信.翌 && (废首 > 当 || 废首 < 当->信.翌))
            break;

    if (废首 + 废首->信.夵 == 当->信.翌)
    { // 附尾
        废首->信.夵 += 当->信.翌->信.夵;
        废首->信.翌 = 当->信.翌->信.翌;
    }
    else
        废首->信.翌 = 当->信.翌;

    if (当 + 当->信.夵 == 废首) // 插首
    {
        当->信.夵 += 废首->信.夵;
        当->信.翌 = 废首->信.翌;
    }
    else
        当->信.翌 = 废首;

    印调("释: 当=%p 当.信.夵=%d 当.信.翌=%p\n", (void *)当, 当->信.夵, (void *)当->信.翌);

    库首 = 当;
}

int main(int argc, char const *argv[])
{
    印调("单位容量: %d", sizeof(头));
#ifdef _手测
    void *配指1, *配指2, *配指3;

    配指1 = 配(100);
    printf("取%x得 %p\n", 100, 配指1);
    // 释(配指);
    配指2 = 配(200);
    printf("取%x得 %p\n", 200, 配指2);
    // 释(配指);
    配指3 = 配(300);
    printf("取%x得 %p\n", 300, 配指3);

    释(配指2);
#else
    void *配指[20];
    int 号 = 0, 配额 = 0;
    for (号 = 0; 号 < 20; 号++)
    {
        配额 = 100 + 号 * 50;
        配指[号] = 配(配额);
        printf("取%x得 %p\n", 配额, 配指[号]);
    }
    for (号 = 0; 号 < 20; 号++)
    {
        if (号 % 2 == 1)
            释(配指[号]);
    }
#endif // _手测

    头 *指 = 库首;
    while (指->信.翌 != 库首)
    {
        printf("([%p]%d,%p)\n", (void *)指, 指->信.夵, (void *)指->信.翌);
        指 = 指->信.翌;
    }

    return 0;
}

void 印调(char *格式, ...)
{
#ifdef _调试
    va_list 参;
    va_start(参, 格式);
    vfprintf(stderr, 格式, 参);
    fprintf(stderr, "\n");
    va_end(参);
#endif
}

/*练习
6. 仿库函式calloc(n,size), 写配物(物数, 物夵)分配容量物数*物夵.
7. 改进上函式配及释, 加参数检测.
8. 写函式块释(块首, 块夵), 释块夵之块至库链.
*/